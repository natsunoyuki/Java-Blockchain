import java.security.NoSuchAlgorithmException; 
import java.util.*;

public class Test{
    //ALWAYS REMEMBER TO SEED THE RNG!
    public static Random random = new Random(System.currentTimeMillis());
    
    public static void main(String args[]){ 
        System.out.println("\nNous sommes des degourdis, nous sommes des lascars!\n");

        BlockChain blockchain = new BlockChain("Tester");

        int M = 8; //acceptable nonce length
        int n; //number of leading zeros in hash
        if(args.length == 0){
            System.out.println("Number of leading zeros not set... using default of 4...\n");
            n = 4; //set default to 4 leading zeros
        } else {
            n = Integer.parseInt(args[0]);
        }

        //The genesis block is always generated by hand!
        blockchain.addBlock(createGenesisBlock(n,M));
        System.out.println("Genesis block successfully created for Yumi with 100 coins.");
        PRINT(blockchain);
    
        blockchain = makeTransaction(n, M, blockchain, "Yumi", "Naomi", 10);
        PRINT(blockchain);

        blockchain = makeTransaction(n, M, blockchain, "Yumi", "Yurie", 50);
        PRINT(blockchain);       
    
        blockchain = makeTransaction(n, M, blockchain, "Yurie", "Tomomi", 60);
        PRINT(blockchain);       

        blockchain = makeTransaction(n, M, blockchain, "Tomomi", "Naomi",100);
        PRINT(blockchain);  
    
        blockchain = makeTransaction(n, M, blockchain, "Yurie", "Yurie",10);
        PRINT(blockchain);
    
        blockchain = makeTransaction(n, M, blockchain, "Naomi", "Yumi",10);
        PRINT(blockchain);
    }  

    public static void PRINT(BlockChain blockchain){
        //This should be defined within BlockChain class! REDO!
        System.out.println(blockchain.getLastBlock());
        System.out.printf("Current blockchain length : %d\n",blockchain.BlockChainLength());
        System.out.println("Accounts : " + blockchain.getLastBlock().getBCData().toString());
        System.out.println();
    }
    
    //function to create the Genesis block of the block chain.
    //This must be outside the Block class
    public static Block createGenesisBlock(int N, int M) {
        //create the genesis block of a block chain. This function 
        //should only be used ONCE!
        System.out.print("Creating block number 1... ");
        long counter = 0;
        int init_nonce_length = 1;
        String init_data_name = "Yumi";
        int init_data_amount = 100;
        String zerostring = SHA.ZeroString(N);
        String init_nonce = RandomString(init_nonce_length);
        String init_hash = SHA.SHA256(init_nonce);
        BCData data = new BCData(init_data_name, init_data_amount);
        Block block = new Block(1,init_nonce,new Date(),data,init_hash);
        while(!block.getCurrentHash().substring(0,N).equals(zerostring)){
            counter++; //count how many iterations in total
            init_nonce += RandomString(1);            
            block = new Block(1,init_nonce,new Date(),data,init_hash);
            if(init_nonce.length() > M){
                //as we do not want too long a nonce, reset the length
                //to 1 after a certain number of trials
                //System.out.printf("\n%d iterations complete...", i);
                init_nonce = RandomString(init_nonce_length);
                block = new Block(1,init_nonce,new Date(),data,init_hash);
            }
            //System.out.println(init_nonce.length());
        } 
        System.out.printf("%d iterations to create genesis block.\n",counter);
        return block;
    }
    
    public static Block createNextBlock(int N, int M, Block prevBlock, String init_data_name, int init_data_amount) {
        //using data from the previous block, create a new block
        int index = prevBlock.getIndex()+1;
        System.out.printf("Creating block number %d... ", index);
        long counter = 0;
        int init_nonce_length = 1;
        String zerostring = SHA.ZeroString(N);
        String init_nonce = RandomString(init_nonce_length);
        String init_hash = prevBlock.getCurrentHash();
        BCData data = new BCData(init_data_name, init_data_amount);
        Block block = new Block(index,init_nonce,new Date(),data,init_hash);
        while(!block.getCurrentHash().substring(0,N).equals(zerostring)){
            counter++; //count how many iterations in total
            init_nonce += RandomString(1);            
            block = new Block(index,init_nonce,new Date(),data,init_hash);
            if(init_nonce.length() > M){
                //as we do not want too long a nonce, reset the length
                //to 1 after a certain number of trials
                //System.out.printf("\n%d iterations complete...", i);
                init_nonce = RandomString(init_nonce_length);
                block = new Block(index,init_nonce,new Date(),data,init_hash);
            }
            //System.out.println(init_nonce.length());
        }
        System.out.printf("%d iterations to create new block.\n",counter);
        return block;
    }

    public static Block createNextBlock(int N, int M, Block prevBlock, String[] init_data_name, int[] init_data_amount) {
        //using data from the previous block, create a new block
        int index = prevBlock.getIndex()+1;
        System.out.printf("Creating block number %d now... ", index);
        long counter = 0;
        int init_nonce_length = 1;
        String zerostring = SHA.ZeroString(N);
        String init_nonce = RandomString(init_nonce_length);
        String init_hash = prevBlock.getCurrentHash();
        BCData data = new BCData(init_data_name, init_data_amount);
        Block block = new Block(index,init_nonce,new Date(),data,init_hash);
        while(!block.getCurrentHash().substring(0,N).equals(zerostring)){
            counter++; //count how many iterations in total
            init_nonce += RandomString(1);            
            block = new Block(index,init_nonce,new Date(),data,init_hash);
            if(init_nonce.length() > M){
                //as we do not want too long a nonce, reset the length
                //to 1 after a certain number of trials
                //System.out.printf("\n%d iterations complete...", i);
                init_nonce = RandomString(init_nonce_length);
                block = new Block(index,init_nonce,new Date(),data,init_hash);
            }
            //System.out.println(init_nonce.length());
        }
        System.out.printf("%d iterations to create new block.\n",counter);
        return block;
    }

    public static Block createNextBlock(int N, int M, Block prevBlock, BCData data) {
        //using data from the previous block, create a new block
        int index = prevBlock.getIndex()+1;
        System.out.printf("Creating block number %d now... ", index);
        long counter = 0;
        int init_nonce_length = 1;
        String zerostring = SHA.ZeroString(N);
        String init_nonce = RandomString(init_nonce_length);
        String init_hash = prevBlock.getCurrentHash();
        Block block = new Block(index,init_nonce,new Date(),data,init_hash);
        while(!block.getCurrentHash().substring(0,N).equals(zerostring)){
            counter++; //count how many iterations in total
            init_nonce += RandomString(1);            
            block = new Block(index,init_nonce,new Date(),data,init_hash);
            if(init_nonce.length() > M){
                //as we do not want too long a nonce, reset the length
                //to 1 after a certain number of trials
                //System.out.printf("\n%d iterations complete...", i);
                init_nonce = RandomString(init_nonce_length);
                block = new Block(index,init_nonce,new Date(),data,init_hash);
            }
            //System.out.println(init_nonce.length());
        }
        System.out.printf("%d iterations to create new block.\n",counter);
        return block;
    }

    //creates a repeating random alpha-numeric string of length N
    public static String RandomString(int N){
        //String a = "abcdefghijklmnopqrstuvwxyz0123456789";
        String a = "0123456789abcdef";
        int alen = a.length();
        String string = "";
        int b;
        for(int i=0;i<N;i++){
            b = random.nextInt(alen);
            string += a.charAt(b);
        }
        return string;
    }   

    public static BlockChain makeTransaction(int n, int M, BlockChain blockchain, String acc1, String acc2, int value){
        //currently we define one block to have exactly one transaction.
        //we define a transaction as acc1 paying value to acc2 
        BCData Data = blockchain.getLastBlock().getBCData();
        if(acc1.equals(acc2)){
            //check if acc1 and acc2 are the same
            System.out.println("Both accounts are the same! Transaction aborted!");
        }else{
            if(Data.hasAccount(acc1)){
                if(Data.getCoinAmount(acc1) >= value){
                    String[] string = {acc1, acc2};
                    int[] i = {Data.getCoinAmount(acc1) - value, value};
                    Data.updateBCData(string, i);
                    blockchain.addBlock(createNextBlock(n,M,blockchain.getLastBlock(), Data));
                    System.out.printf("%s successfully paid %s %d coins! Transaction complete!\n",acc1,acc2,value);
                }else{
                    System.out.printf("%s cannot afford to pay %s %d coins! Transaction aborted!\n",acc1,acc2,value);
                }
            }else{
                System.out.printf("Records of %s do not exist! Transaction aborted!\n",acc1);
            }
        }
        return blockchain;
    }
}
